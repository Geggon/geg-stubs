import typing, clr, abc
from Aml.Engine.CAEX import AttributeType, RefSemanticType, AttributeTypeType, ICAEXLibrary, CAEXBasicObject, ICAEXWrapper, CAEXDocument, CAEXFileType, CAEXObject, CAEXWrapper, CopyrightType, ICAEXBasicObject, DescriptionType, VersionType, ExternalReferenceType, AttributeTypeLibType, InstanceHierarchyType, InterfaceClassLibType, RoleClassLibType, SystemUnitClassLibType, ICAEXObject, SystemUnitClassType, InterfaceClassType, ExternalInterfaceType, IObjectWithExternalInterface, InternalElementType, IObjectWithRoleReference, IClassWithBaseClassReference_1, IInstantiable_1, InterfaceFamilyType, InternalLinkType, MappingType, AttributeNameMappingType, InterfaceNameMappingType, InterfaceIDMappingType, IObjectWithAttributes, AttributeFamilyType, IClassWithBaseClassReference, IClassWithExternalInterface, SystemUnitFamilyType, RoleFamilyType, IInternalElementContainer, SupportedRoleClassType
from System.Collections.Generic import List_1, IEnumerable_1, Dictionary_2, HashSet_1, IEqualityComparer_1
from Aml.Engine.Schema import AMLSchemaManager
from System.Xml.Linq import XElement, XAttribute
from System import Predicate_1, Func_2, Array_1, IComparable
from System.Collections import IEnumerable, IEnumerator
from System.Xml.Schema import XmlTypeCode

class AttributeTypeTypeExtensions(abc.ABC):
    @staticmethod
    def IsMaster(element: AttributeType) -> bool: ...
    @staticmethod
    def IsOverridden(attributeType: AttributeType) -> bool: ...
    @staticmethod
    def IsOverriddenDeleted(attributeType: AttributeType) -> bool: ...
    @staticmethod
    def New_RefSemantic(caexObject: AttributeTypeType, semantic: str) -> RefSemanticType: ...


class CAEXBasicObjectExtensions(abc.ABC):
    @staticmethod
    def AllLibraryReferences(caexObject: CAEXBasicObject) -> List_1[ICAEXLibrary]: ...
    @staticmethod
    def AMLSchemaManager(caexObject: ICAEXWrapper) -> AMLSchemaManager: ...
    @staticmethod
    def AutomationMLEdition(caexObject: CAEXBasicObject) -> str: ...
    @staticmethod
    def CAEXDocument(caexObject: ICAEXWrapper) -> CAEXDocument: ...
    @staticmethod
    def CAEXFile(caexObject: ICAEXWrapper) -> CAEXFileType: ...
    @staticmethod
    def CAEXSchema(caexObject: ICAEXWrapper) -> CAEXDocument.CAEXSchema: ...
    @staticmethod
    def HasNewVersion(caexObject: CAEXBasicObject) -> bool: ...
    @staticmethod
    def HasOldVersion(caexObject: CAEXBasicObject) -> bool: ...
    @staticmethod
    def IsExtendedVersion(caexLibrary: ICAEXLibrary) -> bool: ...
    @staticmethod
    def Library(caexObject: ICAEXWrapper) -> CAEXObject: ...
    @staticmethod
    def Name(caexObject: CAEXWrapper) -> str: ...
    @staticmethod
    def New_Copyright(caexObject: ICAEXBasicObject) -> CopyrightType: ...
    @staticmethod
    def New_Description(caexObject: CAEXBasicObject) -> DescriptionType: ...
    @staticmethod
    def New_Version(caexObject: ICAEXBasicObject) -> VersionType: ...
    # Skipped Ancestors due to it being static, abstract and generic.

    Ancestors : Ancestors_MethodGroup
    class Ancestors_MethodGroup:
        def __getitem__(self, t:typing.Type[Ancestors_1_T1]) -> Ancestors_1[Ancestors_1_T1]: ...

        Ancestors_1_T1 = typing.TypeVar('Ancestors_1_T1')
        class Ancestors_1(typing.Generic[Ancestors_1_T1]):
            Ancestors_1_T = CAEXBasicObjectExtensions.Ancestors_MethodGroup.Ancestors_1_T1
            def __call__(self, caexObject: ICAEXWrapper, includeSelf: bool = ...) -> IEnumerable_1[Ancestors_1_T]:...

        def __call__(self, caexObject: ICAEXWrapper, includeSelf: bool = ...) -> IEnumerable_1[CAEXBasicObject]:...

    # Skipped CreateCaexWrapper due to it being static, abstract and generic.

    CreateCaexWrapper : CreateCaexWrapper_MethodGroup
    class CreateCaexWrapper_MethodGroup:
        def __getitem__(self, t:typing.Type[CreateCaexWrapper_1_T1]) -> CreateCaexWrapper_1[CreateCaexWrapper_1_T1]: ...

        CreateCaexWrapper_1_T1 = typing.TypeVar('CreateCaexWrapper_1_T1')
        class CreateCaexWrapper_1(typing.Generic[CreateCaexWrapper_1_T1]):
            CreateCaexWrapper_1_T = CAEXBasicObjectExtensions.CreateCaexWrapper_MethodGroup.CreateCaexWrapper_1_T1
            def __call__(self, xmlNode: XElement) -> CreateCaexWrapper_1_T:...


    # Skipped Descendants due to it being static, abstract and generic.

    Descendants : Descendants_MethodGroup
    class Descendants_MethodGroup:
        def __getitem__(self, t:typing.Type[Descendants_1_T1]) -> Descendants_1[Descendants_1_T1]: ...

        Descendants_1_T1 = typing.TypeVar('Descendants_1_T1')
        class Descendants_1(typing.Generic[Descendants_1_T1]):
            Descendants_1_T = CAEXBasicObjectExtensions.Descendants_MethodGroup.Descendants_1_T1
            @typing.overload
            def __call__(self, caexObject: CAEXWrapper) -> IEnumerable_1[Descendants_1_T]:...
            @typing.overload
            def __call__(self, caexObject: ICAEXWrapper, includeSelf: bool = ...) -> IEnumerable_1[Descendants_1_T]:...

        @typing.overload
        def __call__(self, caexObject: CAEXWrapper) -> IEnumerable_1[CAEXBasicObject]:...
        @typing.overload
        def __call__(self, caexObject: CAEXWrapper, caexType: typing.Type[typing.Any]) -> IEnumerable_1[CAEXBasicObject]:...

    # Skipped FindCaexObjectFromId due to it being static, abstract and generic.

    FindCaexObjectFromId : FindCaexObjectFromId_MethodGroup
    class FindCaexObjectFromId_MethodGroup:
        def __getitem__(self, t:typing.Type[FindCaexObjectFromId_1_T1]) -> FindCaexObjectFromId_1[FindCaexObjectFromId_1_T1]: ...

        FindCaexObjectFromId_1_T1 = typing.TypeVar('FindCaexObjectFromId_1_T1')
        class FindCaexObjectFromId_1(typing.Generic[FindCaexObjectFromId_1_T1]):
            FindCaexObjectFromId_1_T = CAEXBasicObjectExtensions.FindCaexObjectFromId_MethodGroup.FindCaexObjectFromId_1_T1
            def __call__(self, caexObject: ICAEXWrapper, id: str) -> FindCaexObjectFromId_1_T:...


    # Skipped FindReferencedClass due to it being static, abstract and generic.

    FindReferencedClass : FindReferencedClass_MethodGroup
    class FindReferencedClass_MethodGroup:
        def __getitem__(self, t:typing.Type[FindReferencedClass_1_T1]) -> FindReferencedClass_1[FindReferencedClass_1_T1]: ...

        FindReferencedClass_1_T1 = typing.TypeVar('FindReferencedClass_1_T1')
        class FindReferencedClass_1(typing.Generic[FindReferencedClass_1_T1]):
            FindReferencedClass_1_T = CAEXBasicObjectExtensions.FindReferencedClass_MethodGroup.FindReferencedClass_1_T1
            def __call__(self, caexObject: ICAEXWrapper, caexPath: str) -> FindReferencedClass_1_T:...


    # Skipped FirstAncestor due to it being static, abstract and generic.

    FirstAncestor : FirstAncestor_MethodGroup
    class FirstAncestor_MethodGroup:
        def __getitem__(self, t:typing.Type[FirstAncestor_1_T1]) -> FirstAncestor_1[FirstAncestor_1_T1]: ...

        FirstAncestor_1_T1 = typing.TypeVar('FirstAncestor_1_T1')
        class FirstAncestor_1(typing.Generic[FirstAncestor_1_T1]):
            FirstAncestor_1_T = CAEXBasicObjectExtensions.FirstAncestor_MethodGroup.FirstAncestor_1_T1
            def __call__(self, caexObject: ICAEXWrapper) -> FirstAncestor_1_T:...

        @typing.overload
        def __call__(self, caexObject: ICAEXWrapper, predicate: Predicate_1[ICAEXWrapper]) -> CAEXWrapper:...
        @typing.overload
        def __call__(self, caexObject: ICAEXWrapper, tagName: str) -> CAEXWrapper:...

    # Skipped GetParent due to it being static, abstract and generic.

    GetParent : GetParent_MethodGroup
    class GetParent_MethodGroup:
        def __getitem__(self, t:typing.Type[GetParent_1_T1]) -> GetParent_1[GetParent_1_T1]: ...

        GetParent_1_T1 = typing.TypeVar('GetParent_1_T1')
        class GetParent_1(typing.Generic[GetParent_1_T1]):
            GetParent_1_T = CAEXBasicObjectExtensions.GetParent_MethodGroup.GetParent_1_T1
            def __call__(self, caexObject: ICAEXWrapper) -> GetParent_1_T:...




class CAEXDocumentExtensions(abc.ABC):
    @staticmethod
    def ExternalReferenceFromAlias(document: CAEXDocument, alias: str) -> ExternalReferenceType: ...
    @staticmethod
    def FindByID(document: CAEXDocument, id: str, resolveAlias: bool = ...) -> CAEXObject: ...
    @staticmethod
    def FindByPath(document: CAEXDocument, caexPath: str, resolveAlias: bool = ...) -> CAEXObject: ...
    @staticmethod
    def HasLibraries(document: CAEXDocument) -> bool: ...


class CAEXElementFactory(abc.ABC):
    # Skipped Create due to it being static, abstract and generic.

    Create : Create_MethodGroup
    class Create_MethodGroup:
        def __getitem__(self, t:typing.Type[Create_1_T1]) -> Create_1[Create_1_T1]: ...

        Create_1_T1 = typing.TypeVar('Create_1_T1')
        class Create_1(typing.Generic[Create_1_T1]):
            Create_1_T = CAEXElementFactory.Create_MethodGroup.Create_1_T1
            def __call__(self, document: CAEXDocument) -> Create_1_T:...

        def __call__(self, document: CAEXDocument, caexTagName: str) -> CAEXWrapper:...



class CAEXFileTypeExtensions(abc.ABC):
    @staticmethod
    def GetAMLInfoFromFilename(caexFile: CAEXFileType, producer: clr.Reference[str], domain: clr.Reference[str], version: clr.Reference[str], edition: clr.Reference[str], libType: clr.Reference[str], extension: clr.Reference[str]) -> None: ...
    @staticmethod
    def Import_AttributeTypeLib(caexFile: CAEXFileType, attributeTypeLib: AttributeTypeLibType) -> AttributeTypeLibType: ...
    @staticmethod
    def Import_InstanceHierarchy(caexFile: CAEXFileType, instanceHierarchy: InstanceHierarchyType) -> InstanceHierarchyType: ...
    @staticmethod
    def Import_InterfaceClassLibHierarchy(caexFile: CAEXFileType, interfaceClassLib: InterfaceClassLibType) -> InterfaceClassLibType: ...
    @staticmethod
    def Import_RoleClassLibHierarchy(caexFile: CAEXFileType, roleClassLib: RoleClassLibType) -> RoleClassLibType: ...
    @staticmethod
    def Import_SystemUnitClassLibHierarchy(caexFile: CAEXFileType, systemUnitClassLib: SystemUnitClassLibType) -> SystemUnitClassLibType: ...
    @staticmethod
    def ImportAttributeTypeLib(caexFile: CAEXFileType, attributeTypeLib: AttributeTypeLibType) -> AttributeTypeLibType: ...
    @staticmethod
    def ImportInstanceHierarchy(caexFile: CAEXFileType, instanceHierarchy: InstanceHierarchyType) -> InstanceHierarchyType: ...
    @staticmethod
    def ImportInterfaceClassLib(caexFile: CAEXFileType, interfaceClassLib: InterfaceClassLibType) -> InterfaceClassLibType: ...
    @staticmethod
    def ImportRoleClassLib(caexFile: CAEXFileType, roleClassLib: RoleClassLibType) -> RoleClassLibType: ...
    @staticmethod
    def ImportSystemUnitClassLib(caexFile: CAEXFileType, systemUnitClassLib: SystemUnitClassLibType) -> SystemUnitClassLibType: ...
    @staticmethod
    def Insert_ExternalReference(caexFile: CAEXFileType, externalReference: ExternalReferenceType) -> None: ...
    @staticmethod
    def Insert_InstanceHierarchy(caexFile: CAEXFileType, instanceHierarchyNode: InstanceHierarchyType) -> None: ...
    @staticmethod
    def Insert_InterfaceClassLibHierarchy(caexFile: CAEXFileType, interfaceClassLibNode: InterfaceClassLibType) -> None: ...
    @staticmethod
    def Insert_RoleClassLibHierarchy(caexFile: CAEXFileType, roleClassLib: RoleClassLibType) -> None: ...
    @staticmethod
    def Insert_SystemUnitClassLibHierarchy(caexFile: CAEXFileType, systemUnitClassLib: SystemUnitClassLibType) -> None: ...
    @staticmethod
    def New_ExternalReference(caexFile: CAEXFileType, path: str, alias: str) -> ExternalReferenceType: ...
    @staticmethod
    def New_InstanceHierarchy(caexFile: CAEXFileType, name: str) -> InstanceHierarchyType: ...
    @staticmethod
    def New_InterfaceClassLibHierarchy(caexFile: CAEXFileType, name: str) -> InterfaceClassLibType: ...
    @staticmethod
    def New_RoleClassLibHierarchy(caexFile: CAEXFileType, name: str) -> RoleClassLibType: ...
    @staticmethod
    def New_SystemUnitClassLibHierarchy(caexFile: CAEXFileType, name: str) -> SystemUnitClassLibType: ...
    @staticmethod
    def PreorderTraversal(caexFile: CAEXFileType, source: IEnumerator, childSelector: Func_2[typing.Any, IEnumerator]) -> IEnumerable: ...
    # Skipped FindFastByID due to it being static, abstract and generic.

    FindFastByID : FindFastByID_MethodGroup
    class FindFastByID_MethodGroup:
        def __getitem__(self, t:typing.Type[FindFastByID_1_T1]) -> FindFastByID_1[FindFastByID_1_T1]: ...

        FindFastByID_1_T1 = typing.TypeVar('FindFastByID_1_T1')
        class FindFastByID_1(typing.Generic[FindFastByID_1_T1]):
            FindFastByID_1_T = CAEXFileTypeExtensions.FindFastByID_MethodGroup.FindFastByID_1_T1
            def __call__(self, caexFile: CAEXFileType, ID: str, includeExternals: bool = ...) -> FindFastByID_1_T:...

        def __call__(self, caexFile: CAEXFileType, ID: str, includeExternals: bool = ...) -> CAEXObject:...

    # Skipped FindFastByPath due to it being static, abstract and generic.

    FindFastByPath : FindFastByPath_MethodGroup
    class FindFastByPath_MethodGroup:
        def __getitem__(self, t:typing.Type[FindFastByPath_1_T1]) -> FindFastByPath_1[FindFastByPath_1_T1]: ...

        FindFastByPath_1_T1 = typing.TypeVar('FindFastByPath_1_T1')
        class FindFastByPath_1(typing.Generic[FindFastByPath_1_T1]):
            FindFastByPath_1_T = CAEXFileTypeExtensions.FindFastByPath_MethodGroup.FindFastByPath_1_T1
            def __call__(self, caexFile: CAEXFileType, path: str, includeExternals: bool = ...) -> FindFastByPath_1_T:...

        def __call__(self, caexFile: CAEXFileType, path: str, includeExternals: bool = ...) -> CAEXObject:...



class CAEXObjectExtensions(abc.ABC):
    @staticmethod
    def Copy(caexObject: CAEXObject, name: str) -> CAEXObject: ...
    @staticmethod
    def GetFullNodePath(caexObject: ICAEXObject) -> str: ...
    @staticmethod
    def SetDescription(caexObject: ICAEXObject, description: str) -> None: ...


class CAEXPathBuilder(abc.ABC):
    AliasSeparator : str
    AttributeSeparator : str
    InterfaceSeparator : str
    ObjectSeparator : str
    PathPartBegin : str
    PathPartBeginInName : str
    PathPartEnd : str
    PathPartEndInName : str
    @staticmethod
    def AliasFromReference(classReference: str, schema: CAEXDocument.CAEXSchema) -> str: ...
    @staticmethod
    def CanNormalize(path: str) -> bool: ...
    @staticmethod
    def ChangeAlias(caexPath: str, newAlias: str, oldAlias: str = ...) -> str: ...
    @staticmethod
    def ChangePathStart(caexPath: str, oldPathStart: str, newPathStart: str) -> str: ...
    @staticmethod
    def ContainsPathSeparatorChars(name: str, document: CAEXDocument) -> bool: ...
    @staticmethod
    def ExternalInterfaceIDInAttributeReference(reference: str, cAEXDocument: CAEXDocument, isIdReference: clr.Reference[bool]) -> str: ...
    @staticmethod
    def InstanceIDInAttributeReference(reference: str, document: CAEXDocument, isAttributeReference: clr.Reference[bool]) -> str: ...
    @staticmethod
    def InternalElementIDInInternalLinkReference(reference: str, isInterfaceReference: clr.Reference[bool]) -> str: ...
    @staticmethod
    def IsAlias(pathPart: str) -> bool: ...
    @staticmethod
    def IsAttributeReference(document: CAEXDocument, attributeReference: str) -> bool: ...
    @staticmethod
    def IsIDReferenceWithAlias(objectRefrence: str, document: CAEXDocument, referenceType: CAEXPathBuilder.IDRefEnum = ...) -> bool: ...
    @staticmethod
    def IsInterfaceReference(classReference: str) -> bool: ...
    @staticmethod
    def IsObjectReferenceWithAlias(classReference: str, automationMlClassPath: str, schema: CAEXDocument.CAEXSchema) -> bool: ...
    @staticmethod
    def IsReferenceWithAlias(classReference: str, schema: CAEXDocument.CAEXSchema) -> bool: ...
    @staticmethod
    def IsValidAttributeReferenceID(idString: str, document: CAEXDocument) -> bool: ...
    @staticmethod
    def IsValidID(idString: str, document: CAEXDocument = ...) -> bool: ...
    @staticmethod
    def NormalizePath(path: str, isNormalized: clr.Reference[bool], schema: CAEXDocument.CAEXSchema) -> str: ...
    @staticmethod
    def PathNameArray(path: str, schema: CAEXDocument.CAEXSchema, keepPathPartBrackets: bool = ...) -> Array_1[str]: ...
    @staticmethod
    def PathNameArrayWithSeparator(path: str, schema: CAEXDocument.CAEXSchema, onlyAlias: bool = ...) -> Array_1[str]: ...
    @staticmethod
    def PathNameListWithSeparator(path: str, schema: CAEXDocument.CAEXSchema, onlyAliasSeparator: bool = ...) -> List_1[str]: ...
    @staticmethod
    def PathPartName(name: str, schema: CAEXDocument.CAEXSchema) -> str: ...
    @staticmethod
    def PathPartObjectNames(path: str, schema: CAEXDocument.CAEXSchema, keepPathPartBrackets: bool = ...) -> IEnumerable_1[str]: ...
    @staticmethod
    def PathPartObjectNamesWithSeparator(path: str, schema: CAEXDocument.CAEXSchema, onlyAlias: bool = ...) -> IEnumerable_1[str]: ...
    @staticmethod
    def RemoveAlias(path: str, alias: str = ...) -> str: ...
    @staticmethod
    def SeparatorChars(schema: CAEXDocument.CAEXSchema) -> Array_1[str]: ...
    # Skipped CAEXPath due to it being static, abstract and generic.

    CAEXPath : CAEXPath_MethodGroup
    class CAEXPath_MethodGroup:
        @typing.overload
        def __call__(self, elementNodes: IEnumerable_1[XElement]) -> str:...
        @typing.overload
        def __call__(self, elements: IEnumerable_1[CAEXObject]) -> str:...
        @typing.overload
        def __call__(self, names: Array_1[str], schema: CAEXDocument.CAEXSchema) -> str:...

    # Skipped InternalLinkReferencePath due to it being static, abstract and generic.

    InternalLinkReferencePath : InternalLinkReferencePath_MethodGroup
    class InternalLinkReferencePath_MethodGroup:
        @typing.overload
        def __call__(self, systemUnitClass: SystemUnitClassType, interfaceClass: InterfaceClassType) -> str:...
        @typing.overload
        def __call__(self, interfaceParent: XElement, externalInterface: XElement) -> str:...

    # Skipped PathPart due to it being static, abstract and generic.

    PathPart : PathPart_MethodGroup
    class PathPart_MethodGroup:
        @typing.overload
        def __call__(self, element: CAEXObject, useId: bool = ...) -> str:...
        @typing.overload
        def __call__(self, element: XElement, useId: bool = ...) -> str:...

    # Skipped PathPartSeparator due to it being static, abstract and generic.

    PathPartSeparator : PathPartSeparator_MethodGroup
    class PathPartSeparator_MethodGroup:
        @typing.overload
        def __call__(self, element: CAEXObject) -> str:...
        @typing.overload
        def __call__(self, element: XElement) -> str:...


    class IDRefEnum(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        AttributeReference : CAEXPathBuilder.IDRefEnum # 1
        InterfaceReference : CAEXPathBuilder.IDRefEnum # 4
        InternalElementReference : CAEXPathBuilder.IDRefEnum # 8
        AllTypes : CAEXPathBuilder.IDRefEnum # 13



class CaexValue(IComparable):
    @property
    def DefaultValue(self) -> typing.Any: ...
    @property
    def FriendlyValueString(self) -> str: ...
    @property
    def TypeAttribute(self) -> XAttribute: ...
    @property
    def TypeCodeOfAttribute(self) -> XmlTypeCode: ...
    @property
    def Value(self) -> typing.Any: ...
    @Value.setter
    def Value(self, value: typing.Any) -> typing.Any: ...
    @property
    def ValueElement(self) -> XElement: ...
    @ValueElement.setter
    def ValueElement(self, value: XElement) -> XElement: ...
    def CompareTo(self, obj: typing.Any) -> int: ...
    def Equals(self, obj: typing.Any) -> bool: ...
    def GetHashCode(self) -> int: ...
    def IsBinaryValue(self) -> bool: ...
    def IsDateTimeType(self) -> bool: ...
    def IsNumericOrBooleanValue(self) -> bool: ...
    def IsNumericValue(self) -> bool: ...
    def IsPartOfDateValue(self) -> bool: ...
    def IsStringValue(self) -> bool: ...
    def IsValidStringValue(self, value: str) -> str: ...
    @staticmethod
    def TypeCode(xsdSchemaType: str) -> XmlTypeCode: ...


class ExternalInterfaceTypeExtensions(abc.ABC):
    @staticmethod
    def HasVerifiableCardinality(externalInterface: ExternalInterfaceType) -> bool: ...
    @staticmethod
    def IsMaster(externalInterface: ExternalInterfaceType) -> bool: ...
    @staticmethod
    def IsOverridden(externalInterface: ExternalInterfaceType) -> bool: ...
    @staticmethod
    def IsOverriddenDeleted(externalInterface: ExternalInterfaceType) -> bool: ...
    @staticmethod
    def IsRelated(externalInterface: ExternalInterfaceType) -> bool: ...
    @staticmethod
    def MaxCardinality(externalInterface: ExternalInterfaceType) -> typing.Optional[int]: ...
    @staticmethod
    def MaxCardinalityViolation(externalInterface: ExternalInterfaceType) -> bool: ...
    @staticmethod
    def MinCardinality(externalInterface: ExternalInterfaceType) -> typing.Optional[int]: ...
    @staticmethod
    def MinCardinalityViolation(externalInterface: ExternalInterfaceType) -> bool: ...
    @staticmethod
    def OfInterfaceClass(objectWithExternalInterface: IObjectWithExternalInterface, interfaceClassPath: str) -> IEnumerable_1[ExternalInterfaceType]: ...
    @staticmethod
    def RelatedExternalInterfaces(externalInterface: ExternalInterfaceType) -> IEnumerable_1[ExternalInterfaceType]: ...
    @staticmethod
    def RelatedInstances(externalInterface: ExternalInterfaceType) -> IEnumerable_1[SystemUnitClassType]: ...
    @staticmethod
    def RelatedInternalElementsWithRoleReference(externalInterface: ExternalInterfaceType, roleClassPath: str) -> IEnumerable_1[InternalElementType]: ...


class InheritanceExtensions(abc.ABC):
    @classmethod
    @property
    def DerivedClasses(cls) -> InheritanceExtensions.DerivedClassDictionary: ...
    @staticmethod
    def IsDerivedFromAttributeType(attribute: AttributeTypeType, attributeTypePath: str) -> bool: ...
    @staticmethod
    def IsDerivedFromInterfaceClass(interfaceClass: InterfaceClassType, interfaceClassPath: str) -> bool: ...
    @staticmethod
    def IsDerivedFromRoleClass(roleReference: IObjectWithRoleReference, roleClassPath: str) -> bool: ...
    # Skipped ChangeNameAndReferences due to it being static, abstract and generic.

    ChangeNameAndReferences : ChangeNameAndReferences_MethodGroup
    class ChangeNameAndReferences_MethodGroup:
        def __getitem__(self, t:typing.Type[ChangeNameAndReferences_1_T1]) -> ChangeNameAndReferences_1[ChangeNameAndReferences_1_T1]: ...

        ChangeNameAndReferences_1_T1 = typing.TypeVar('ChangeNameAndReferences_1_T1')
        class ChangeNameAndReferences_1(typing.Generic[ChangeNameAndReferences_1_T1]):
            ChangeNameAndReferences_1_T = InheritanceExtensions.ChangeNameAndReferences_MethodGroup.ChangeNameAndReferences_1_T1
            def __call__(self, caexClass: IClassWithBaseClassReference_1[ChangeNameAndReferences_1_T], name: str) -> None:...


    # Skipped ClassIsDerivedFrom due to it being static, abstract and generic.

    ClassIsDerivedFrom : ClassIsDerivedFrom_MethodGroup
    class ClassIsDerivedFrom_MethodGroup:
        def __getitem__(self, t:typing.Type[ClassIsDerivedFrom_1_T1]) -> ClassIsDerivedFrom_1[ClassIsDerivedFrom_1_T1]: ...

        ClassIsDerivedFrom_1_T1 = typing.TypeVar('ClassIsDerivedFrom_1_T1')
        class ClassIsDerivedFrom_1(typing.Generic[ClassIsDerivedFrom_1_T1]):
            ClassIsDerivedFrom_1_T = InheritanceExtensions.ClassIsDerivedFrom_MethodGroup.ClassIsDerivedFrom_1_T1
            @typing.overload
            def __call__(self, classWithReference: IClassWithBaseClassReference_1[ClassIsDerivedFrom_1_T], baseClass: IClassWithBaseClassReference_1[ClassIsDerivedFrom_1_T]) -> typing.Optional[bool]:...
            @typing.overload
            def __call__(self, classWithReference: IClassWithBaseClassReference_1[ClassIsDerivedFrom_1_T], baseClassPath: str) -> typing.Optional[bool]:...
            @typing.overload
            def __call__(self, document: CAEXDocument, classPath: str, baseClassPath: str) -> typing.Optional[bool]:...


    # Skipped CopyTreeAndChangeReferences due to it being static, abstract and generic.

    CopyTreeAndChangeReferences : CopyTreeAndChangeReferences_MethodGroup
    class CopyTreeAndChangeReferences_MethodGroup:
        def __getitem__(self, t:typing.Type[CopyTreeAndChangeReferences_1_T1]) -> CopyTreeAndChangeReferences_1[CopyTreeAndChangeReferences_1_T1]: ...

        CopyTreeAndChangeReferences_1_T1 = typing.TypeVar('CopyTreeAndChangeReferences_1_T1')
        class CopyTreeAndChangeReferences_1(typing.Generic[CopyTreeAndChangeReferences_1_T1]):
            CopyTreeAndChangeReferences_1_T = InheritanceExtensions.CopyTreeAndChangeReferences_MethodGroup.CopyTreeAndChangeReferences_1_T1
            def __call__(self, source: IClassWithBaseClassReference_1[CopyTreeAndChangeReferences_1_T], parent: CAEXObject, name: str) -> CopyTreeAndChangeReferences_1_T:...


    # Skipped CreateClassInstance due to it being static, abstract and generic.

    CreateClassInstance : CreateClassInstance_MethodGroup
    class CreateClassInstance_MethodGroup:
        def __getitem__(self, t:typing.Type[CreateClassInstance_1_T1]) -> CreateClassInstance_1[CreateClassInstance_1_T1]: ...

        CreateClassInstance_1_T1 = typing.TypeVar('CreateClassInstance_1_T1')
        class CreateClassInstance_1(typing.Generic[CreateClassInstance_1_T1]):
            CreateClassInstance_1_T = InheritanceExtensions.CreateClassInstance_MethodGroup.CreateClassInstance_1_T1
            def __call__(self, caexClass: IInstantiable_1[CreateClassInstance_1_T], name: str) -> CAEXBasicObject:...



    class DerivedClassDictionary(Dictionary_2[str, HashSet_1[str]]):
        def __init__(self) -> None: ...
        @property
        def Comparer(self) -> IEqualityComparer_1[str]: ...
        @property
        def Count(self) -> int: ...
        @property
        def Item(self) -> HashSet_1[str]: ...
        @Item.setter
        def Item(self, value: HashSet_1[str]) -> HashSet_1[str]: ...
        @property
        def Keys(self) -> Dictionary_2.KeyCollection_2[str, HashSet_1[str]]: ...
        @property
        def Values(self) -> Dictionary_2.ValueCollection_2[str, HashSet_1[str]]: ...
        def AddClassDerivations(self, document: CAEXDocument, classPath: str, className: str) -> None: ...



class InstanceHierarchyTypeExtensions(abc.ABC):
    @staticmethod
    def InternalElementDescendants(instanceHierarchy: InstanceHierarchyType) -> IEnumerable_1[InternalElementType]: ...


class InterfaceClassLibTypeExtensions(abc.ABC):
    @staticmethod
    def Insert_InterfaceClass(interfaceClassLib: InterfaceClassLibType, interfaceFamilyType: InterfaceFamilyType) -> None: ...
    @staticmethod
    def InterfaceClassDescendants(interfaceClassLib: InterfaceClassLibType) -> IEnumerable_1[InterfaceFamilyType]: ...
    @staticmethod
    def New_InterfaceClass(interfaceClassLib: InterfaceClassLibType, name: str) -> InterfaceClassType: ...


class InterfaceFamilyTypeExtensions(abc.ABC):
    @staticmethod
    def CreateInterfaceFamilyClass(interfaceClass: InterfaceClassType) -> InterfaceFamilyType: ...
    @staticmethod
    def Insert_InterfaceClass(interfaceClass: InterfaceFamilyType, newInterface: InterfaceFamilyType) -> None: ...
    @staticmethod
    def InterfaceClassDescendants(interfaceClass: InterfaceFamilyType) -> IEnumerable_1[InterfaceFamilyType]: ...
    @staticmethod
    def New_InterfaceClass(interfaceClass: InterfaceFamilyType, name: str) -> InterfaceClassType: ...


class InternalElementExtensions(abc.ABC):
    @staticmethod
    def IsMaster(element: InternalElementType) -> bool: ...
    @staticmethod
    def IsOverridden(internalElement: InternalElementType) -> bool: ...
    @staticmethod
    def IsOverriddenDeleted(internalElement: InternalElementType) -> bool: ...


class InternalLinkTypeExtensions(abc.ABC):
    @staticmethod
    def GetRefPartnerSideAExternalInterfaceId(internalLink: InternalLinkType) -> str: ...
    @staticmethod
    def GetRefPartnerSideAInternalElementId(internalLink: InternalLinkType) -> str: ...
    @staticmethod
    def GetRefPartnerSideBExternalInterfaceId(internalLink: InternalLinkType) -> str: ...
    @staticmethod
    def GetRefPartnerSideBInternalElementId(internalLink: InternalLinkType) -> str: ...
    @staticmethod
    def SetRefPartnerSideAExternalInterfaceId(internalLink: InternalLinkType, id: str) -> None: ...
    @staticmethod
    def SetRefPartnerSideAInternalElementId(internalLink: InternalLinkType, id: str) -> None: ...
    @staticmethod
    def SetRefPartnerSideBExternalInterfaceId(internalLink: InternalLinkType, id: str) -> None: ...
    @staticmethod
    def SetRefPartnerSideBInternalElementId(internalLink: InternalLinkType, id: str) -> None: ...


class MappingTypeExtensions(abc.ABC):
    @staticmethod
    def Insert_AttributeNameMapping(mappingObject: MappingType, attributeNameMapping: AttributeNameMappingType) -> None: ...
    @staticmethod
    def Insert_InterfaceNameMapping(mappingObject: MappingType, interfaceNameMapping: InterfaceNameMappingType) -> None: ...
    @staticmethod
    def New_AttributeNameMapping(mappingObject: MappingType, systemUnitAttributeName: str, roleAttributeName: str) -> AttributeNameMappingType: ...
    @staticmethod
    def New_InterfaceNameMapping(mappingObject: MappingType, systemUnitInterfaceName: str, roleInterfaceName: str) -> InterfaceNameMappingType: ...
    # Skipped New_InterfaceIDMapping due to it being static, abstract and generic.

    New_InterfaceIDMapping : New_InterfaceIDMapping_MethodGroup
    class New_InterfaceIDMapping_MethodGroup:
        @typing.overload
        def __call__(self, mappingObject: MappingType, systemUnitInterface: ExternalInterfaceType, roleInterface: ExternalInterfaceType) -> InterfaceIDMappingType:...
        @typing.overload
        def __call__(self, mappingObject: MappingType, systemUnitInterfaceID: str, roleInterfaceID: str) -> InterfaceIDMappingType:...



class ObjectWithAttributes(abc.ABC):
    @staticmethod
    def CopyAttributesFrom(targetObject: IObjectWithAttributes, sourceObject: IObjectWithAttributes, includingValues: bool) -> None: ...
    @staticmethod
    def GetAttribute(caexObject: IObjectWithAttributes, name: str) -> AttributeType: ...
    @staticmethod
    def New_Attribute(caexObject: IObjectWithAttributes, name: str) -> AttributeType: ...
    # Skipped AddAttributeTypeReference due to it being static, abstract and generic.

    AddAttributeTypeReference : AddAttributeTypeReference_MethodGroup
    class AddAttributeTypeReference_MethodGroup:
        @typing.overload
        def __call__(self, ObjectWithAttribute: IObjectWithAttributes, attributeClass: AttributeFamilyType, addUnique: bool = ..., addInstance: bool = ..., name: str = ...) -> AttributeType:...
        @typing.overload
        def __call__(self, ObjectWithAttribute: IObjectWithAttributes, attributeClassReference: str, addUnique: bool = ..., addInstance: bool = ..., name: str = ...) -> AttributeType:...

    # Skipped SetAttributeValue due to it being static, abstract and generic.

    SetAttributeValue : SetAttributeValue_MethodGroup
    class SetAttributeValue_MethodGroup:
        def __getitem__(self, t:typing.Type[SetAttributeValue_1_T1]) -> SetAttributeValue_1[SetAttributeValue_1_T1]: ...

        SetAttributeValue_1_T1 = typing.TypeVar('SetAttributeValue_1_T1')
        class SetAttributeValue_1(typing.Generic[SetAttributeValue_1_T1]):
            SetAttributeValue_1_T = ObjectWithAttributes.SetAttributeValue_MethodGroup.SetAttributeValue_1_T1
            def __call__(self, objWithAttr: IObjectWithAttributes, attName: str, attValue: SetAttributeValue_1_T) -> AttributeType:...

        @typing.overload
        def __call__(self, objWithAttr: IObjectWithAttributes, attName: str, attValue: float) -> AttributeType:...
        @typing.overload
        def __call__(self, objWithAttr: IObjectWithAttributes, attName: str, attValue: str) -> AttributeType:...
        @typing.overload
        def __call__(self, objWithAttr: IObjectWithAttributes, attName: str, attValue: str, attUnit: str, attAttributeDataType: str) -> AttributeType:...
        @typing.overload
        def __call__(self, objWithAttr: IObjectWithAttributes, attName: str, attValue: float, defaultValue: float, description: str, attUnit: str) -> AttributeType:...
        @typing.overload
        def __call__(self, objWithAttr: IObjectWithAttributes, attName: str, attValue: str, defaultValue: str, description: str, attUnit: str, attAttributeDataType: str) -> AttributeType:...



class ObjectWithBaseClass(abc.ABC):
    @staticmethod
    def DeleteInheritedElement(classWithBaseClass: IClassWithBaseClassReference, elementName: str, elementType: typing.Type[typing.Any]) -> bool: ...
    @staticmethod
    def GetDerivedAttributes(classWithBaseClass: IClassWithBaseClassReference, includeOwn: bool = ...) -> List_1[AttributeType]: ...
    @staticmethod
    def GetDerivedInterfaces(classWithBaseClass: IClassWithExternalInterface, includeOwn: bool = ...) -> List_1[ExternalInterfaceType]: ...
    @staticmethod
    def GetInheritedAttributes(classWithBaseClass: IClassWithBaseClassReference, includeSelf: bool = ...) -> IEnumerable_1[AttributeType]: ...
    @staticmethod
    def GetInheritedAttributesAndDescendants(classWithBaseClass: IClassWithBaseClassReference, includeOwn: bool = ...) -> List_1[AttributeType]: ...
    @staticmethod
    def GetInheritedElements(classWithBaseClass: SystemUnitFamilyType, includeSelf: bool) -> IEnumerable_1[InternalElementType]: ...
    @staticmethod
    def GetInheritedInterfaces(classWithBaseClass: IClassWithExternalInterface, includeSelf: bool = ...) -> IEnumerable_1[ExternalInterfaceType]: ...
    @staticmethod
    def GetInheritedInterfacesAndDescendants(classWithBaseClass: IClassWithExternalInterface, includeOwn: bool = ...) -> List_1[ExternalInterfaceType]: ...
    @staticmethod
    def IsInherited(classWithBaseClass: IClassWithBaseClassReference, element: CAEXBasicObject) -> bool: ...
    @staticmethod
    def IsOverridden(classWithBaseClass: IClassWithBaseClassReference, element: CAEXBasicObject) -> bool: ...
    @staticmethod
    def OverriddenElement(classWithBaseClass: IClassWithBaseClassReference, elementName: str, elementType: typing.Type[typing.Any]) -> XElement: ...
    # Skipped AddChildWithReference due to it being static, abstract and generic.

    AddChildWithReference : AddChildWithReference_MethodGroup
    class AddChildWithReference_MethodGroup:
        def __getitem__(self, t:typing.Type[AddChildWithReference_1_T1]) -> AddChildWithReference_1[AddChildWithReference_1_T1]: ...

        AddChildWithReference_1_T1 = typing.TypeVar('AddChildWithReference_1_T1')
        class AddChildWithReference_1(typing.Generic[AddChildWithReference_1_T1]):
            AddChildWithReference_1_T = ObjectWithBaseClass.AddChildWithReference_MethodGroup.AddChildWithReference_1_T1
            def __call__(self, classWithBaseClass: IClassWithBaseClassReference_1[AddChildWithReference_1_T], name: str, isReferenced: clr.Reference[bool]) -> AddChildWithReference_1_T:...


    # Skipped InheritedElements due to it being static, abstract and generic.

    InheritedElements : InheritedElements_MethodGroup
    class InheritedElements_MethodGroup:
        def __getitem__(self, t:typing.Type[InheritedElements_1_T1]) -> InheritedElements_1[InheritedElements_1_T1]: ...

        InheritedElements_1_T1 = typing.TypeVar('InheritedElements_1_T1')
        class InheritedElements_1(typing.Generic[InheritedElements_1_T1]):
            InheritedElements_1_TInheritedElement = ObjectWithBaseClass.InheritedElements_MethodGroup.InheritedElements_1_T1
            def __call__(self, classWithBaseClass: IClassWithBaseClassReference, includeSelf: bool = ...) -> IEnumerable_1[InheritedElements_1_TInheritedElement]:...


    # Skipped ReferencedClassName due to it being static, abstract and generic.

    ReferencedClassName : ReferencedClassName_MethodGroup
    class ReferencedClassName_MethodGroup:
        @typing.overload
        def __call__(self, internalElement: InternalElementType) -> str:...
        @typing.overload
        def __call__(self, interfaceClass: InterfaceClassType) -> str:...
        @typing.overload
        def __call__(self, objectWithClassReference: IClassWithBaseClassReference) -> str:...



class ObjectWithExternalInterface(abc.ABC):
    @staticmethod
    def InterfaceClassReferences(objectWithExternalInterface: IObjectWithExternalInterface, interfaceReference: str, regardInheritance: bool = ...) -> IEnumerable_1[ExternalInterfaceType]: ...
    # Skipped AddInterfaceClassReference due to it being static, abstract and generic.

    AddInterfaceClassReference : AddInterfaceClassReference_MethodGroup
    class AddInterfaceClassReference_MethodGroup:
        @typing.overload
        def __call__(self, ObjectWithExternalInterface: IObjectWithExternalInterface, interfaceClass: InterfaceFamilyType, addUnique: bool = ..., addInstance: bool = ..., name: str = ...) -> ExternalInterfaceType:...
        @typing.overload
        def __call__(self, ObjectWithExternalInterface: IObjectWithExternalInterface, interfaceClassReference: str, addUnique: bool = ..., addInstance: bool = ..., name: str = ...) -> ExternalInterfaceType:...

    # Skipped HasInterfaceClassReference due to it being static, abstract and generic.

    HasInterfaceClassReference : HasInterfaceClassReference_MethodGroup
    class HasInterfaceClassReference_MethodGroup:
        @typing.overload
        def __call__(self, objectWithExternalInterface: IObjectWithExternalInterface, interfaceClass: InterfaceFamilyType, regardInheritance: bool = ...) -> bool:...
        @typing.overload
        def __call__(self, objectWithExternalInterface: IObjectWithExternalInterface, interfaceReference: str, regardInheritance: bool = ...) -> bool:...



class RoleClassFamilyTypeExtensions(abc.ABC):
    @staticmethod
    def Insert_RoleClass(roleClassAncestor: RoleFamilyType, roleClass: RoleFamilyType) -> None: ...
    @staticmethod
    def New_RoleClass(roleClassFamily: RoleFamilyType, roleClassName: str) -> RoleFamilyType: ...
    @staticmethod
    def RoleClassDescendants(roleClassFamily: RoleFamilyType) -> IEnumerable_1[RoleFamilyType]: ...


class RoleClassLibTypeExtensions(abc.ABC):
    @staticmethod
    def Insert_RoleClass(roleClassLib: RoleClassLibType, roleClass: RoleFamilyType) -> None: ...
    @staticmethod
    def New_RoleClass(roleClassLib: RoleClassLibType, roleClassName: str) -> RoleFamilyType: ...
    @staticmethod
    def RoleClassDescendants(roleClassLib: RoleClassLibType) -> IEnumerable_1[RoleFamilyType]: ...


class StringExtensions(abc.ABC):
    @staticmethod
    def IsClassReference(attributeName: str) -> bool: ...
    @staticmethod
    def IsGUID(stringGuid: str, allowAnyString: bool = ...) -> bool: ...
    @staticmethod
    def IsInterfacePath(path: str) -> bool: ...
    @staticmethod
    def IsInterfacePathWithID(path: str, id: str, schema: CAEXDocument.CAEXSchema) -> bool: ...
    @staticmethod
    def IsInterfacePathWithInterface(path: str, interfaceName: str, schema: CAEXDocument.CAEXSchema) -> bool: ...
    @staticmethod
    def NormalizedGUID(stringGuid: str) -> str: ...


class SystemUnitClassLibTypeExtensions(abc.ABC):
    @staticmethod
    def Insert_SystemUnitClass(systemUnitClassLib: SystemUnitClassLibType, systemUnitClass: SystemUnitFamilyType) -> None: ...
    @staticmethod
    def New_SystemUnitClass(systemUnitClassLib: SystemUnitClassLibType, systemUnitClassName: str) -> SystemUnitFamilyType: ...
    @staticmethod
    def SystemUnitClassDescendants(systemUnitClassLib: SystemUnitClassLibType) -> IEnumerable_1[SystemUnitFamilyType]: ...


class SystemUnitClassTypeExtensions(abc.ABC):
    @staticmethod
    def AddInstance(systemUnitClass: SystemUnitClassType, newInstanceObject: CAEXObject) -> bool: ...
    @staticmethod
    def AddNewInternalElement(systemUnitClass: SystemUnitClassType, elementName: str) -> InternalElementType: ...
    @staticmethod
    def Ancestors(systemUnitClass: SystemUnitFamilyType) -> IEnumerable_1[SystemUnitFamilyType]: ...
    @staticmethod
    def Append_InternalElement(systemUnitClass: SystemUnitClassType, internalElement: InternalElementType, internalElementPredecessor: InternalElementType) -> None: ...
    @staticmethod
    def Insert_Attribute(objectWithAttributes: IObjectWithAttributes, attributeElement: AttributeType) -> None: ...
    @staticmethod
    def Insert_ExternalInterface(objectWithExternalInterface: IObjectWithExternalInterface, interfaceElement: ExternalInterfaceType, asFirst: bool = ...) -> None: ...
    @staticmethod
    def Insert_InternalElement(objectWithInternalElements: IInternalElementContainer, internalElement: InternalElementType, asFirst: bool = ...) -> None: ...
    @staticmethod
    def Insert_InternalLink(systemUnitClass: SystemUnitClassType, internalLinkElement: InternalLinkType, asFirst: bool = ...) -> None: ...
    @staticmethod
    def Insert_SupportedRoleClass(systemUnitClass: SystemUnitClassType, supportedRoleClassElement: SupportedRoleClassType, asFirst: bool = ...) -> None: ...
    @staticmethod
    def New_InternalElement(elementWithInternalElements: IInternalElementContainer, elementName: str, asFirst: bool = ...) -> InternalElementType: ...
    @staticmethod
    def New_InternalLink(systemUnitClass: SystemUnitClassType, name: str, asFirst: bool = ...) -> InternalLinkType: ...
    @staticmethod
    def New_SupportedRoleClass(systemUnitClass: SystemUnitClassType, referencedRoleClassPath: str, asFirst: bool = ...) -> SupportedRoleClassType: ...
    # Skipped New_ExternalInterface due to it being static, abstract and generic.

    New_ExternalInterface : New_ExternalInterface_MethodGroup
    class New_ExternalInterface_MethodGroup:
        @typing.overload
        def __call__(self, objectWithExternalInterface: IObjectWithExternalInterface, name: str, asFirst: bool = ...) -> ExternalInterfaceType:...
        @typing.overload
        def __call__(self, objectWithExternalInterface: IObjectWithExternalInterface, name: str, interfaceClassPath: str, asFirst: bool = ...) -> ExternalInterfaceType:...



class SystemUnitFamilyTypeExtensions(abc.ABC):
    @staticmethod
    def GetDerivedSupportedRoles(systemUnitClass: SystemUnitFamilyType, includeOwn: bool = ...) -> List_1[SupportedRoleClassType]: ...
    @staticmethod
    def Insert_SystemUnitClass(systemUnitClassAncestor: SystemUnitFamilyType, systemUnitClass: SystemUnitFamilyType) -> None: ...
    @staticmethod
    def New_SystemUnitClass(systemUnitFamilyType: SystemUnitFamilyType, systemUnitClassName: str) -> SystemUnitFamilyType: ...
    @staticmethod
    def SystemUnitClassDescendants(systemUnitFamilyType: SystemUnitFamilyType) -> IEnumerable_1[SystemUnitFamilyType]: ...

