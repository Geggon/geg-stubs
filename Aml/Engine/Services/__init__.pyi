import typing, clr, abc
from Aml.Engine.Services.Interfaces import ICAEXReference, ILookUpTable, IQuery, IAutoUpdate, IExternalReferenceResolver, IUndoRedo, IUniqueName, IAMLService, ISigning
from System.Xml.Linq import XElement
from Aml.Engine.CAEX import CAEXBasicObject, CAEXDocument, InternalElementType, SystemUnitClassType, ExternalInterfaceType, InternalLinkType, AttributeType, CAEXObject
from System.Linq import ILookup_2
from System.Collections.Generic import IEnumerable_1
from System import Action, Func_1, ValueTuple_2
from Aml.Engine.Services.Model import XMLSignature

class CAEXReference(ICAEXReference):
    def __init__(self, element: XElement, referenceAttributeName: str) -> None: ...
    @property
    def CaexObject(self) -> CAEXBasicObject: ...
    @property
    def Element(self) -> XElement: ...
    @property
    def ReferenceAttributeName(self) -> str: ...
    @property
    def ReferenceAttributeValue(self) -> str: ...
    def SetValue(self, value: str) -> None: ...


class EmptyLookup_GenericClasses(abc.ABCMeta):
    Generic_EmptyLookup_GenericClasses_EmptyLookup_2_TKey = typing.TypeVar('Generic_EmptyLookup_GenericClasses_EmptyLookup_2_TKey')
    Generic_EmptyLookup_GenericClasses_EmptyLookup_2_TElement = typing.TypeVar('Generic_EmptyLookup_GenericClasses_EmptyLookup_2_TElement')
    def __getitem__(self, types : typing.Tuple[typing.Type[Generic_EmptyLookup_GenericClasses_EmptyLookup_2_TKey], typing.Type[Generic_EmptyLookup_GenericClasses_EmptyLookup_2_TElement]]) -> typing.Type[EmptyLookup_2[Generic_EmptyLookup_GenericClasses_EmptyLookup_2_TKey, Generic_EmptyLookup_GenericClasses_EmptyLookup_2_TElement]]: ...

EmptyLookup : EmptyLookup_GenericClasses

EmptyLookup_2_TKey = typing.TypeVar('EmptyLookup_2_TKey')
EmptyLookup_2_TElement = typing.TypeVar('EmptyLookup_2_TElement')
class EmptyLookup_2(typing.Generic[EmptyLookup_2_TKey, EmptyLookup_2_TElement], abc.ABC):
    @classmethod
    @property
    def Instance(cls) -> ILookup_2[EmptyLookup_2_TKey, EmptyLookup_2_TElement]: ...


class QueryResult(abc.ABC):
    @staticmethod
    def AllCaexObjects(queryResult: ILookup_2[str, ICAEXReference]) -> IEnumerable_1[CAEXBasicObject]: ...
    @staticmethod
    def AllElementsIdentifiedByCAEXPath(doc: CAEXDocument) -> ILookup_2[str, ICAEXReference]: ...
    @staticmethod
    def AllElementsWithAliasReference(doc: CAEXDocument) -> ILookup_2[str, ICAEXReference]: ...
    @staticmethod
    def AllElementsWithCAEXPathReference(doc: CAEXDocument) -> ILookup_2[str, ICAEXReference]: ...
    @staticmethod
    def AllElementsWithIDReference(doc: CAEXDocument) -> ILookup_2[str, ICAEXReference]: ...
    @staticmethod
    def AllElementsWithIDs(doc: CAEXDocument) -> ILookup_2[str, ICAEXReference]: ...
    @staticmethod
    def AllElementsWithNameReference(doc: CAEXDocument) -> ILookup_2[str, ICAEXReference]: ...
    @staticmethod
    def AllInternalElementMasters(doc: CAEXDocument) -> IEnumerable_1[InternalElementType]: ...
    @staticmethod
    def AllInternalElementMirrors(doc: CAEXDocument) -> IEnumerable_1[InternalElementType]: ...
    @staticmethod
    def ElementsWithAliasReference(doc: CAEXDocument, alias: str) -> IEnumerable_1[ICAEXReference]: ...
    @staticmethod
    def ElementsWithCAEXPathReference(doc: CAEXDocument, path: str) -> IEnumerable_1[ICAEXReference]: ...
    @staticmethod
    def ElementsWithIDReference(doc: CAEXDocument, ID: str) -> IEnumerable_1[ICAEXReference]: ...
    @staticmethod
    def ElementsWithInternalLinkRelations(doc: CAEXDocument) -> IEnumerable_1[SystemUnitClassType]: ...
    @staticmethod
    def ExternalInterfaces(queryResult: ILookup_2[str, ICAEXReference]) -> IEnumerable_1[ExternalInterfaceType]: ...
    @staticmethod
    def InternalElementMirrors(master: InternalElementType) -> IEnumerable_1[InternalElementType]: ...
    @staticmethod
    def InternalElements(queryResult: ILookup_2[str, ICAEXReference]) -> IEnumerable_1[InternalElementType]: ...
    @staticmethod
    def InternalLinks(queryResult: ILookup_2[str, ICAEXReference]) -> IEnumerable_1[InternalLinkType]: ...
    @staticmethod
    def InternalLinksToElement(systemUnitClass: SystemUnitClassType) -> IEnumerable_1[InternalLinkType]: ...
    @staticmethod
    def InternalLinksToInterface(externalInterface: ExternalInterfaceType) -> IEnumerable_1[InternalLinkType]: ...
    @staticmethod
    def ReferencesWithName(queryResult: ILookup_2[str, ICAEXReference], name: str) -> IEnumerable_1[CAEXBasicObject]: ...
    # Skipped CaexObjectsOfType due to it being static, abstract and generic.

    CaexObjectsOfType : CaexObjectsOfType_MethodGroup
    class CaexObjectsOfType_MethodGroup:
        def __getitem__(self, t:typing.Type[CaexObjectsOfType_1_T1]) -> CaexObjectsOfType_1[CaexObjectsOfType_1_T1]: ...

        CaexObjectsOfType_1_T1 = typing.TypeVar('CaexObjectsOfType_1_T1')
        class CaexObjectsOfType_1(typing.Generic[CaexObjectsOfType_1_T1]):
            CaexObjectsOfType_1_T = QueryResult.CaexObjectsOfType_MethodGroup.CaexObjectsOfType_1_T1
            def __call__(self, queryResult: ILookup_2[str, ICAEXReference]) -> IEnumerable_1[CaexObjectsOfType_1_T]:...




class QueryService(ILookUpTable, IQuery):
    def __init__(self) -> None: ...
    def AllElementsIdentifiedByCAEXPath(self, caexObject: CAEXBasicObject) -> ILookup_2[str, ICAEXReference]: ...
    def AllElementsWithAliasReference(self, caexObject: CAEXBasicObject, elementName: str = ...) -> ILookup_2[str, ICAEXReference]: ...
    def AllElementsWithCAEXPathReference(self, caexObject: CAEXBasicObject, elementName: str = ..., includeSelf: bool = ...) -> ILookup_2[str, ICAEXReference]: ...
    def AllElementsWithIDReference(self, caexObject: CAEXBasicObject, elementName: str = ...) -> ILookup_2[str, ICAEXReference]: ...
    def AllElementsWithIDs(self, caexObject: CAEXBasicObject, ID: str = ...) -> ILookup_2[str, ICAEXReference]: ...
    def AllElementsWithInternalLinks(self, caexObject: CAEXBasicObject) -> IEnumerable_1[SystemUnitClassType]: ...
    def AllElementsWithNameReference(self, caexObject: CAEXBasicObject, elementName: str = ...) -> ILookup_2[str, ICAEXReference]: ...
    def AllExternalDataReferences(self, document: CAEXDocument, caexObject: CAEXBasicObject = ...) -> IEnumerable_1[ExternalInterfaceType]: ...
    def AllExternalInterfacesOfType(self, document: CAEXDocument, interfaceClassPath: str, caexObject: CAEXBasicObject = ...) -> IEnumerable_1[ExternalInterfaceType]: ...
    def AllInternalElementsWithInternalLinks(self, caexObject: CAEXBasicObject) -> IEnumerable_1[InternalElementType]: ...
    def AttributeMirrors(self, master: AttributeType) -> IEnumerable_1[AttributeType]: ...
    def ElementsWithAliasReference(self, caexObject: CAEXBasicObject, alias: str, elementName: str = ...) -> IEnumerable_1[ICAEXReference]: ...
    def ElementsWithCAEXPathReference(self, caexObject: CAEXBasicObject, caexPath: str, elementName: str = ...) -> IEnumerable_1[ICAEXReference]: ...
    def ElementsWithIDReference(self, caexObject: CAEXBasicObject, ID: str, elementName: str = ...) -> IEnumerable_1[ICAEXReference]: ...
    def ElementsWithInternalLinkRelations(self, caexObject: CAEXBasicObject) -> IEnumerable_1[SystemUnitClassType]: ...
    def ExternalInterfaceMirrors(self, master: ExternalInterfaceType) -> IEnumerable_1[ExternalInterfaceType]: ...
    def FindByID(self, caexDocument: CAEXDocument, id: str, resolveAlias: bool = ...) -> CAEXObject: ...
    def FindByPath(self, caexDocument: CAEXDocument, path: str, resolveAlias: bool = ...) -> CAEXObject: ...
    def IDTableIsLoaded(self, document: CAEXDocument) -> bool: ...
    def InterfacesWithInternalLinkRelations(self, caexObject: CAEXBasicObject) -> IEnumerable_1[ExternalInterfaceType]: ...
    def InternalElementMirrors(self, master: InternalElementType) -> IEnumerable_1[InternalElementType]: ...
    def InternalLinksToElement(self, systemUnitClass: SystemUnitClassType) -> IEnumerable_1[InternalLinkType]: ...
    def InternalLinksToInterface(self, externalInterface: ExternalInterfaceType) -> IEnumerable_1[InternalLinkType]: ...
    def IsReferenced(self, caexObject: CAEXObject) -> bool: ...
    def LoadIDTable(self, document: CAEXDocument) -> None: ...
    def LoadPathTable(self, document: CAEXDocument) -> None: ...
    def PathTableIsLoaded(self, document: CAEXDocument) -> bool: ...
    def UnloadIDTable(self, document: CAEXDocument) -> None: ...
    def UnloadPathTable(self, document: CAEXDocument) -> None: ...
    # Skipped AllClassReferences due to it being static, abstract and generic.

    AllClassReferences : AllClassReferences_MethodGroup
    class AllClassReferences_MethodGroup:
        @typing.overload
        def __call__(self, caexObject: CAEXObject) -> IEnumerable_1[CAEXObject]:...
        @typing.overload
        def __call__(self, document: CAEXDocument, classPath: str, elementName: str = ...) -> IEnumerable_1[CAEXObject]:...

    # Skipped AllClassReferencesDeep due to it being static, abstract and generic.

    AllClassReferencesDeep : AllClassReferencesDeep_MethodGroup
    class AllClassReferencesDeep_MethodGroup:
        @typing.overload
        def __call__(self, caexObject: CAEXObject) -> IEnumerable_1[CAEXObject]:...
        @typing.overload
        def __call__(self, document: CAEXDocument, classPath: str, elementName: str = ...) -> IEnumerable_1[CAEXObject]:...

    # Skipped IsMaster due to it being static, abstract and generic.

    IsMaster : IsMaster_MethodGroup
    class IsMaster_MethodGroup:
        @typing.overload
        def __call__(self, attribute: AttributeType) -> bool:...
        @typing.overload
        def __call__(self, element: InternalElementType) -> bool:...
        @typing.overload
        def __call__(self, element: ExternalInterfaceType) -> bool:...



class ServiceLocator(abc.ABC):
    @classmethod
    @property
    def AutoUpdateService(cls) -> IAutoUpdate: ...
    @classmethod
    @property
    def ExternalReferenceResolverService(cls) -> IExternalReferenceResolver: ...
    @classmethod
    @property
    def QueryService(cls) -> IQuery: ...
    @classmethod
    @property
    def UndoRedoService(cls) -> IUndoRedo: ...
    @classmethod
    @property
    def UniqueNameService(cls) -> IUniqueName: ...
    @staticmethod
    def EndService(unregister: Action, service: IAMLService) -> None: ...
    # Skipped BeginService due to it being static, abstract and generic.

    BeginService : BeginService_MethodGroup
    class BeginService_MethodGroup:
        def __getitem__(self, t:typing.Type[BeginService_1_T1]) -> BeginService_1[BeginService_1_T1]: ...

        BeginService_1_T1 = typing.TypeVar('BeginService_1_T1')
        class BeginService_1(typing.Generic[BeginService_1_T1]):
            BeginService_1_T = ServiceLocator.BeginService_MethodGroup.BeginService_1_T1
            def __call__(self, register: Func_1[BeginService_1_T], service: clr.Reference[BeginService_1_T]) -> None:...


    # Skipped GetService due to it being static, abstract and generic.

    GetService : GetService_MethodGroup
    class GetService_MethodGroup:
        def __getitem__(self, t:typing.Type[GetService_1_T1]) -> GetService_1[GetService_1_T1]: ...

        GetService_1_T1 = typing.TypeVar('GetService_1_T1')
        class GetService_1(typing.Generic[GetService_1_T1]):
            GetService_1_T = ServiceLocator.GetService_MethodGroup.GetService_1_T1
            def __call__(self) -> GetService_1_T:...


    # Skipped Register due to it being static, abstract and generic.

    Register : Register_MethodGroup
    class Register_MethodGroup:
        def __getitem__(self, t:typing.Type[Register_1_T1]) -> Register_1[Register_1_T1]: ...

        Register_1_T1 = typing.TypeVar('Register_1_T1')
        class Register_1(typing.Generic[Register_1_T1]):
            Register_1_T = ServiceLocator.Register_MethodGroup.Register_1_T1
            def __call__(self, service: Register_1_T) -> None:...


    # Skipped UnRegister due to it being static, abstract and generic.

    UnRegister : UnRegister_MethodGroup
    class UnRegister_MethodGroup:
        def __getitem__(self, t:typing.Type[UnRegister_1_T1]) -> UnRegister_1[UnRegister_1_T1]: ...

        UnRegister_1_T1 = typing.TypeVar('UnRegister_1_T1')
        class UnRegister_1(typing.Generic[UnRegister_1_T1]):
            UnRegister_1_T = ServiceLocator.UnRegister_MethodGroup.UnRegister_1_T1
            def __call__(self) -> IAMLService:...




class SignatureServiceBase(ISigning, abc.ABC):
    def CAEXNodeToString(self, caexObject: CAEXObject) -> str: ...
    def ComputeSignature(self, CAEXObjectToSign: CAEXObject, privateKey: str, passPhrase: str) -> str: ...
    def CreateSignature(self, CAEXObjectToSign: CAEXObject, privateKey: str, passPhrase: str, publicKey: str = ...) -> str: ...
    @abc.abstractmethod
    def GenerateKeys(self, passPhrase: str) -> ValueTuple_2[str, str]: ...
    @abc.abstractmethod
    def ToEnvelopedSignature(self, signatureID: str, signatureValue: str, publicKey: str) -> XMLSignature: ...
    # Skipped VerifySignature due to it being static, abstract and generic.

    VerifySignature : VerifySignature_MethodGroup
    class VerifySignature_MethodGroup:
        @typing.overload
        def __call__(self, CAEXObjectToVerify: CAEXObject, publicKey: str = ...) -> typing.Optional[bool]:...
        @typing.overload
        def __call__(self, CAEXObjectToVerify: CAEXObject, signature: str, publicKey: str) -> typing.Optional[bool]:...


