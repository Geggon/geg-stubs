import typing, clr, abc
from Aml.Engine.CAEX import CAEXDocument, CAEXBasicObject, ExternalReferenceType, SystemUnitClassType, ExternalInterfaceType, InternalElementType, AttributeType, CAEXObject, InternalLinkType, ICAEXWrapper, CAEXFileType
from System.Collections.Generic import List_1, IEnumerable_1
from Aml.Engine.Services.Model import NetworkProtocolEnum, AMLLibraryServerData, AMLFileModel, AMLLibraryServer, XMLSignature
from System.Threading.Tasks import Task_1
from System.IO import Stream
from Aml.Engine.AmlObjects import IAMLFile, AutomationMLContainer
from Aml.Engine.Resources import PublicLibraryCatalog
from System import ValueTuple_2, Func_2, Array_1, DateTime, EventArgs
from System.Xml.Linq import XElement, XName, XObject
from System.Linq import ILookup_2
from Aml.Engine.CAEX.Commands import ICAEXCommand
from Aml.Engine.XML import XDocumentWrapper

class IAMLEditionTransform(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def TransformFromEdition1ToEdition2(self, document: CAEXDocument) -> CAEXDocument: ...


class IAMLLibraryService(IAMLService, typing.Protocol):
    @property
    def NetworkProtocolls(self) -> List_1[NetworkProtocolEnum]: ...
    @abc.abstractmethod
    def FileUri(self, data: AMLLibraryServerData, fileName: str) -> str: ...
    @abc.abstractmethod
    def GetAMLExampleDocumentsAsync(self, data: AMLLibraryServerData) -> Task_1[List_1[AMLFileModel]]: ...
    @abc.abstractmethod
    def GetAMLLibraryCollectionsAsync(self, data: AMLLibraryServerData) -> Task_1[List_1[AMLFileModel]]: ...
    @abc.abstractmethod
    def GetAMLLibraryDocumentsAsync(self, data: AMLLibraryServerData) -> Task_1[List_1[AMLFileModel]]: ...
    @abc.abstractmethod
    def GetStreamAsync(self, data: AMLLibraryServerData, filename: str) -> Task_1[Stream]: ...
    @abc.abstractmethod
    def LoadAMLFileAsync(self, fileModel: AMLFileModel) -> Task_1[IAMLFile]: ...
    @abc.abstractmethod
    def LoadLibraryCatalogAsync(self, data: AMLLibraryServerData) -> Task_1[PublicLibraryCatalog]: ...
    @abc.abstractmethod
    def PutStreamAsync(self, data: AMLLibraryServerData, fileName: str, fileStream: Stream, exchange: bool = ...) -> Task_1[ValueTuple_2[bool, str]]: ...
    @abc.abstractmethod
    def RegisterServerAsync(self, server: AMLLibraryServer) -> Task_1[bool]: ...
    @abc.abstractmethod
    def UploadAMLLibraryDocumentAsync(self, data: AMLLibraryServerData, amlLibraryDocument: CAEXDocument, replace: bool) -> Task_1[ValueTuple_2[bool, str]]: ...


class IAMLService(typing.Protocol):
    pass


class IAutoUpdate(IAMLService, typing.Protocol):
    @property
    def IsAutoUpdateEnabled(self) -> bool: ...
    @IsAutoUpdateEnabled.setter
    def IsAutoUpdateEnabled(self, value: bool) -> bool: ...


class ICAEXReference(typing.Protocol):
    @property
    def CaexObject(self) -> CAEXBasicObject: ...
    @property
    def ReferenceAttributeName(self) -> str: ...
    @property
    def ReferenceAttributeValue(self) -> str: ...
    @abc.abstractmethod
    def SetValue(self, value: str) -> None: ...


class ICredentials(typing.Protocol):
    @property
    def IsAnonymous(self) -> bool: ...
    @property
    def Password(self) -> str: ...
    @Password.setter
    def Password(self, value: str) -> str: ...
    @property
    def UserName(self) -> str: ...
    @UserName.setter
    def UserName(self, value: str) -> str: ...


class IDatabaseService(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def Elements(self, element: XElement, name: XName, insert: bool = ...) -> IEnumerable_1[XElement]: ...


class IExternalReferenceResolver(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def CanResolve(self, externalAddress: str) -> bool: ...
    @abc.abstractmethod
    def IsExternal(self, element: XElement, alias: clr.Reference[str]) -> bool: ...
    @abc.abstractmethod
    def RegisterExternalDocument(self, externalReference: ExternalReferenceType, document: CAEXDocument) -> None: ...
    @abc.abstractmethod
    def RegisterResolverFunction(self, resolverFunction: Func_2[str, CAEXDocument]) -> None: ...
    @abc.abstractmethod
    def ResolvedDocuments(self, documentWithExternals: CAEXDocument) -> IEnumerable_1[CAEXDocument]: ...
    @abc.abstractmethod
    def ResolveExternalDocument(self, url: str) -> ValueTuple_2[CAEXDocument, str]: ...
    @abc.abstractmethod
    def SetRedirection(self, address: str, redirectAddress: str) -> None: ...
    # Skipped ClearRedirection due to it being static, abstract and generic.

    ClearRedirection : ClearRedirection_MethodGroup
    class ClearRedirection_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, address: str) -> None:...

    # Skipped LoadOrGetReferencedDocument due to it being static, abstract and generic.

    LoadOrGetReferencedDocument : LoadOrGetReferencedDocument_MethodGroup
    class LoadOrGetReferencedDocument_MethodGroup:
        @typing.overload
        def __call__(self, externalReference: ExternalReferenceType) -> ValueTuple_2[CAEXDocument, str]:...
        @typing.overload
        def __call__(self, document: CAEXDocument, path: str) -> ValueTuple_2[CAEXDocument, str]:...



class IExternalReferenceResolverAsync(IExternalReferenceResolver, typing.Protocol):
    @abc.abstractmethod
    def CanResolveAsync(self, externalAddress: str) -> Task_1[bool]: ...
    @abc.abstractmethod
    def ResolveExternalDocumentAsync(self, url: str) -> Task_1[ValueTuple_2[CAEXDocument, str]]: ...
    # Skipped LoadOrGetReferencedDocumentAsync due to it being static, abstract and generic.

    LoadOrGetReferencedDocumentAsync : LoadOrGetReferencedDocumentAsync_MethodGroup
    class LoadOrGetReferencedDocumentAsync_MethodGroup:
        @typing.overload
        def __call__(self, externalReference: ExternalReferenceType) -> Task_1[ValueTuple_2[CAEXDocument, str]]:...
        @typing.overload
        def __call__(self, document: CAEXDocument, path: str) -> Task_1[ValueTuple_2[CAEXDocument, str]]:...



class ILookUpTable(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def IDTableIsLoaded(self, document: CAEXDocument) -> bool: ...
    @abc.abstractmethod
    def LoadIDTable(self, document: CAEXDocument) -> None: ...
    @abc.abstractmethod
    def LoadPathTable(self, document: CAEXDocument) -> None: ...
    @abc.abstractmethod
    def PathTableIsLoaded(self, document: CAEXDocument) -> bool: ...
    @abc.abstractmethod
    def UnloadIDTable(self, document: CAEXDocument) -> None: ...
    @abc.abstractmethod
    def UnloadPathTable(self, document: CAEXDocument) -> None: ...


class IMerge(IAMLService, typing.Protocol):
    # Skipped Merge due to it being static, abstract and generic.

    Merge : Merge_MethodGroup
    class Merge_MethodGroup:
        @typing.overload
        def __call__(self, document: CAEXDocument, externalReference: ExternalReferenceType, mergeProtocol: clr.Reference[Array_1[str]], autoTransform: bool = ...) -> bool:...
        @typing.overload
        def __call__(self, document: CAEXDocument, externalReference: ExternalReferenceType, externalSource: Stream, mergeProtocol: clr.Reference[Array_1[str]], autoTransform: bool = ...) -> bool:...



class IQuery(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def AllElementsIdentifiedByCAEXPath(self, caexObject: CAEXBasicObject) -> ILookup_2[str, ICAEXReference]: ...
    @abc.abstractmethod
    def AllElementsWithAliasReference(self, caexObject: CAEXBasicObject, elementName: str = ...) -> ILookup_2[str, ICAEXReference]: ...
    @abc.abstractmethod
    def AllElementsWithCAEXPathReference(self, caexObject: CAEXBasicObject, elementName: str = ..., includeSelf: bool = ...) -> ILookup_2[str, ICAEXReference]: ...
    @abc.abstractmethod
    def AllElementsWithIDReference(self, caexObject: CAEXBasicObject, elementName: str = ...) -> ILookup_2[str, ICAEXReference]: ...
    @abc.abstractmethod
    def AllElementsWithIDs(self, caexObject: CAEXBasicObject, ID: str = ...) -> ILookup_2[str, ICAEXReference]: ...
    @abc.abstractmethod
    def AllElementsWithInternalLinks(self, caexObject: CAEXBasicObject) -> IEnumerable_1[SystemUnitClassType]: ...
    @abc.abstractmethod
    def AllElementsWithNameReference(self, caexObject: CAEXBasicObject, elementName: str = ...) -> ILookup_2[str, ICAEXReference]: ...
    @abc.abstractmethod
    def AllExternalDataReferences(self, document: CAEXDocument, caexObject: CAEXBasicObject = ...) -> IEnumerable_1[ExternalInterfaceType]: ...
    @abc.abstractmethod
    def AllExternalInterfacesOfType(self, document: CAEXDocument, interfaceClassPath: str, caexObject: CAEXBasicObject = ...) -> IEnumerable_1[ExternalInterfaceType]: ...
    @abc.abstractmethod
    def AllInternalElementsWithInternalLinks(self, caexObject: CAEXBasicObject) -> IEnumerable_1[InternalElementType]: ...
    @abc.abstractmethod
    def AttributeMirrors(self, master: AttributeType) -> IEnumerable_1[AttributeType]: ...
    @abc.abstractmethod
    def ElementsWithAliasReference(self, caexObject: CAEXBasicObject, alias: str, elementName: str = ...) -> IEnumerable_1[ICAEXReference]: ...
    @abc.abstractmethod
    def ElementsWithCAEXPathReference(self, caexObject: CAEXBasicObject, caexPath: str, elementName: str = ...) -> IEnumerable_1[ICAEXReference]: ...
    @abc.abstractmethod
    def ElementsWithIDReference(self, caexObject: CAEXBasicObject, ID: str, elementName: str = ...) -> IEnumerable_1[ICAEXReference]: ...
    @abc.abstractmethod
    def ElementsWithInternalLinkRelations(self, caexObject: CAEXBasicObject) -> IEnumerable_1[SystemUnitClassType]: ...
    @abc.abstractmethod
    def ExternalInterfaceMirrors(self, master: ExternalInterfaceType) -> IEnumerable_1[ExternalInterfaceType]: ...
    @abc.abstractmethod
    def FindByID(self, doc: CAEXDocument, id: str, resolveAlias: bool = ...) -> CAEXObject: ...
    @abc.abstractmethod
    def FindByPath(self, caexDocument: CAEXDocument, path: str, resolveAlias: bool = ...) -> CAEXObject: ...
    @abc.abstractmethod
    def InterfacesWithInternalLinkRelations(self, caexObject: CAEXBasicObject) -> IEnumerable_1[ExternalInterfaceType]: ...
    @abc.abstractmethod
    def InternalElementMirrors(self, master: InternalElementType) -> IEnumerable_1[InternalElementType]: ...
    @abc.abstractmethod
    def InternalLinksToElement(self, systemUnitClass: SystemUnitClassType) -> IEnumerable_1[InternalLinkType]: ...
    @abc.abstractmethod
    def InternalLinksToInterface(self, externalInterface: ExternalInterfaceType) -> IEnumerable_1[InternalLinkType]: ...
    @abc.abstractmethod
    def IsReferenced(self, caexObject: CAEXObject) -> bool: ...
    # Skipped AllClassReferences due to it being static, abstract and generic.

    AllClassReferences : AllClassReferences_MethodGroup
    class AllClassReferences_MethodGroup:
        @typing.overload
        def __call__(self, caexObject: CAEXObject) -> IEnumerable_1[CAEXObject]:...
        @typing.overload
        def __call__(self, document: CAEXDocument, classPath: str, elementName: str = ...) -> IEnumerable_1[CAEXObject]:...

    # Skipped AllClassReferencesDeep due to it being static, abstract and generic.

    AllClassReferencesDeep : AllClassReferencesDeep_MethodGroup
    class AllClassReferencesDeep_MethodGroup:
        @typing.overload
        def __call__(self, caexObject: CAEXObject) -> IEnumerable_1[CAEXObject]:...
        @typing.overload
        def __call__(self, document: CAEXDocument, classPath: str, elementName: str = ...) -> IEnumerable_1[CAEXObject]:...

    # Skipped IsMaster due to it being static, abstract and generic.

    IsMaster : IsMaster_MethodGroup
    class IsMaster_MethodGroup:
        @typing.overload
        def __call__(self, attribute: AttributeType) -> bool:...
        @typing.overload
        def __call__(self, element: InternalElementType) -> bool:...
        @typing.overload
        def __call__(self, element: ExternalInterfaceType) -> bool:...



class ISchemaTransform(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def TransformTo(self, document: CAEXDocument, targetSchema: CAEXDocument.CAEXSchema) -> CAEXDocument: ...


class ISigning(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def ComputeSignature(self, CAEXObjectToSign: CAEXObject, privateKey: str, passPhrase: str) -> str: ...
    @abc.abstractmethod
    def CreateSignature(self, CAEXObjectToSign: CAEXObject, privateKey: str, passPhrase: str, publicKey: str = ...) -> str: ...
    @abc.abstractmethod
    def GenerateKeys(self, passPhrase: str) -> ValueTuple_2[str, str]: ...
    @abc.abstractmethod
    def ToEnvelopedSignature(self, signatureID: str, signatureValue: str, publicKey: str) -> XMLSignature: ...
    # Skipped VerifySignature due to it being static, abstract and generic.

    VerifySignature : VerifySignature_MethodGroup
    class VerifySignature_MethodGroup:
        @typing.overload
        def __call__(self, CAEXObjectToVerify: CAEXObject, publicKey: str = ...) -> typing.Optional[bool]:...
        @typing.overload
        def __call__(self, CAEXObjectToVerify: CAEXObject, signature: str, publicKey: str) -> typing.Optional[bool]:...



class ISplit(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def RemoveSplitPoint(self, caexObject: ISplitPoint) -> None: ...
    @abc.abstractmethod
    def SetSplitPoint(self, caexObject: ISplitPoint) -> None: ...
    @abc.abstractmethod
    def SplitPoints(self, document: CAEXDocument) -> IEnumerable_1[ISplitPoint]: ...
    # Skipped Split due to it being static, abstract and generic.

    Split : Split_MethodGroup
    class Split_MethodGroup:
        @typing.overload
        def __call__(self, document: CAEXDocument, alias: str, filePath: str) -> CAEXDocument:...
        @typing.overload
        def __call__(self, document: CAEXDocument, splitPoint: ISplitPoint, alias: str, filePath: str) -> CAEXDocument:...



class ISplitPoint(ICAEXWrapper, typing.Protocol):
    pass


class IStatistic(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def NumberOfAllObjects(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfAttributes(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfAttributeTypeReferences(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfAttributeTypes(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfInterfaceClasses(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfInterfaceInstances(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfInternalElements(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfLinks(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfRoleClasses(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfRoleClassReferences(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfSystemUnitClasses(self, caexFile: CAEXFileType) -> int: ...
    @abc.abstractmethod
    def NumberOfSystemUnitClassReferences(self, caexFile: CAEXFileType) -> int: ...


class IUndoRedo(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def BeginTransaction(self, document: CAEXDocument, name: str = ...) -> bool: ...
    @abc.abstractmethod
    def CanRedo(self, document: CAEXDocument) -> bool: ...
    @abc.abstractmethod
    def CanUndo(self, document: CAEXDocument) -> bool: ...
    @abc.abstractmethod
    def ClearStacks(self, document: CAEXDocument) -> None: ...
    @abc.abstractmethod
    def EndTransaction(self, document: CAEXDocument) -> bool: ...
    @abc.abstractmethod
    def LastModificationDate(self, document: CAEXDocument, undo: bool = ...) -> DateTime: ...
    @abc.abstractmethod
    def Pause(self, document: CAEXDocument) -> None: ...
    @abc.abstractmethod
    def PushCommand(self, cmd: ICAEXCommand) -> None: ...
    @abc.abstractmethod
    def Redo(self, document: CAEXDocument) -> None: ...
    @abc.abstractmethod
    def RedoActions(self, document: CAEXDocument) -> IEnumerable_1[str]: ...
    @abc.abstractmethod
    def Resume(self, document: CAEXDocument) -> None: ...
    @abc.abstractmethod
    def Undo(self, document: CAEXDocument) -> None: ...
    @abc.abstractmethod
    def UndoActions(self, document: CAEXDocument) -> IEnumerable_1[str]: ...


class IUniqueName(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def IsUniqueCAEXName(self, element: XElement) -> bool: ...
    @abc.abstractmethod
    def RegisterDefault(self, elementTagName: str, defaultName: str) -> None: ...
    @abc.abstractmethod
    def Resume(self) -> None: ...
    @abc.abstractmethod
    def Suspend(self) -> None: ...
    # Skipped UniqueCAEXName due to it being static, abstract and generic.

    UniqueCAEXName : UniqueCAEXName_MethodGroup
    class UniqueCAEXName_MethodGroup:
        @typing.overload
        def __call__(self, sequence: XElement, elementTagName: str) -> str:...
        @typing.overload
        def __call__(self, sequence: XElement, elementTagName: str, defaultName: str) -> str:...
        @typing.overload
        def __call__(self, sequence: IEnumerable_1[XElement], elementTagName: str, defaultName: str) -> str:...



class IValidationResult(typing.Protocol):
    @property
    def Element(self) -> XElement: ...
    @property
    def RepairResult(self) -> str: ...
    @property
    def ValidationInformation(self) -> str: ...
    @ValidationInformation.setter
    def ValidationInformation(self, value: str) -> str: ...


class IValidator_GenericClasses(abc.ABCMeta):
    Generic_IValidator_GenericClasses_IValidator_1_RESULTTYPE = typing.TypeVar('Generic_IValidator_GenericClasses_IValidator_1_RESULTTYPE')
    def __getitem__(self, types : typing.Type[Generic_IValidator_GenericClasses_IValidator_1_RESULTTYPE]) -> typing.Type[IValidator_1[Generic_IValidator_GenericClasses_IValidator_1_RESULTTYPE]]: ...

class IValidator(IValidator_0, metaclass =IValidator_GenericClasses): ...

class IValidator_0(IAMLService, typing.Protocol):
    @abc.abstractmethod
    def IDValidation(self, caexObject: CAEXObject, ID: str) -> ValueTuple_2[bool, str]: ...
    @abc.abstractmethod
    def NameValidation(self, caexObject: CAEXObject, name: str) -> ValueTuple_2[bool, str]: ...


IValidator_1_RESULTTYPE = typing.TypeVar('IValidator_1_RESULTTYPE')
class IValidator_1(typing.Generic[IValidator_1_RESULTTYPE], IValidator_0, typing.Protocol):
    @abc.abstractmethod
    def Repair(self, validation: IValidator_1_RESULTTYPE) -> bool: ...
    @abc.abstractmethod
    def ValidateAliasReferences(self, document: CAEXDocument, generateLongDescription: bool = ...) -> IEnumerable_1[IValidator_1_RESULTTYPE]: ...
    # Skipped ValidateAll due to it being static, abstract and generic.

    ValidateAll : ValidateAll_MethodGroup[IValidator_1_RESULTTYPE]
    ValidateAll_MethodGroup_IValidator_1_RESULTTYPE = typing.TypeVar('ValidateAll_MethodGroup_IValidator_1_RESULTTYPE')
    class ValidateAll_MethodGroup(typing.Generic[ValidateAll_MethodGroup_IValidator_1_RESULTTYPE]):
        ValidateAll_MethodGroup_IValidator_1_RESULTTYPE = IValidator_1.ValidateAll_MethodGroup_IValidator_1_RESULTTYPE
        @typing.overload
        def __call__(self, document: CAEXDocument, generateLongDescription: bool = ...) -> IEnumerable_1[ValidateAll_MethodGroup_IValidator_1_RESULTTYPE]:...
        @typing.overload
        def __call__(self, document: CAEXDocument, container: AutomationMLContainer, generateLongDescription: bool = ...) -> IEnumerable_1[ValidateAll_MethodGroup_IValidator_1_RESULTTYPE]:...



class IXMLDocumentRegistry(typing.Protocol):
    @abc.abstractmethod
    def RemoveDocument(self, document: XDocumentWrapper) -> None: ...


class IXMLExternalUnload(typing.Protocol):
    @abc.abstractmethod
    def UnloadExternalDocument(self, externalReference: ExternalReferenceType) -> None: ...


class SchemaTransformationEventArgs(EventArgs):
    def __init__(self, sourceDocument: CAEXDocument, targetSchema: CAEXDocument.CAEXSchema) -> None: ...
    @property
    def SourceDocument(self) -> CAEXDocument: ...
    @property
    def TargetDocument(self) -> CAEXDocument: ...
    @TargetDocument.setter
    def TargetDocument(self, value: CAEXDocument) -> CAEXDocument: ...
    @property
    def TargetSchema(self) -> CAEXDocument.CAEXSchema: ...


class UpdateEventArgs(EventArgs):
    @typing.overload
    def __init__(self, referencedElement: XElement, reference: XObject) -> None: ...
    @typing.overload
    def __init__(self, referencedElement: XElement, reference: XObject, newValue: str) -> None: ...
    @property
    def Reference(self) -> XObject: ...
    @property
    def ReferencedElement(self) -> XElement: ...
    @property
    def UpdateValue(self) -> str: ...

